%rebase templates/parts/chapter.html
<h1>TextGrid</h1>
<hr/>

<p> TextGrid is an alternative to images for those who are visually impaired. </p>

<br>

<h2> What is a TextGrid? </h2>

<p> Similar to how images are made of square pixels, TextGrid objects are made of cells that contain a character value. </p>

<p> Here's an example of a 3x3 TextGrid that represents a patch of DNA:  </p>

<p> 
  <b> 
  ATC <br> 
  CTG <br> 
  TGA
  </b>
</p>

<p> Similar to images and pixels, each cell has x and y coordinates in the grid. The origin (0,0) is at the upper-left corner. <b> y </b> increases going down, <b> x </b> increases going right </p>

<p> 
<iframe src="https://docs.google.com/presentation/d/e/2PACX-1vTODK8pn_E8l_d_utmndR-rkwJmtBIX7zKPilDVZ7iQ46BLLrw_4XO1fzS4Mx6ugrJQVFltB9vDggNG/embed?start=false&loop=false&delayms=3000" frameborder="0" width="100%" height="500" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe>
</p>

<h2> TextGrid Library </h2>

<p> In folders for assignment or lecture on images, there is a file <b> textgrid.py </b>. This is the TextGrid library, and you will use this library to work with images. </p>

<p> To use the TextGrid library in your code, include at the top of your program file: </p>

<code class="language-python">from textgrid import TextGrid </code>

<p> This is importing the TextGrid module, so that it is accessible in the code you write. This is similar to when you used <code> import random </code> to use the random number generator library  </p>

<h3> Functions in TextGrid Library </h3>

<p> You can create a TextGrid object by reading from a text file and storing it in a variable</p>

<code class="language-python">grid = TextGrid('foo').txt  </code>

<p> You can create a blank TextGrid object by specifying a width and a height</p>

<code class="language-python">grid = TextGrid.blank(400,200)  </code>

<h3> Accessing Letters in a TextGrid </h3>

<p> We can use a new kind of loop called a "for-each" loop. Here's what it looks like: </p>

<pre class="language-python"><code>for item in collection: 
  # Do something with item 
</code></pre>

<p> Here's how to use a for-each loop with a TextGrid: </p>

<pre class="language-python"><code>
for cell in grid:
        # The code here gets repeated once for each cell in the grid
</code></pre>

<h3> Accessing data inside a TextGrid element </h3>

<p> Each TextGrid image has properties you can access. For example, this is how you can access the width and height of a TextGrid: </p>

<code class="language-python">grid.width, grid.height </code>

<p> Each cell in a TextGrid also has properties: </p>

<p> You can get the x and y coordinates of a cell: </p>

<code class="language-python">cell.x, cell.y </code>

<p> You can also get the character value storied in a cell: </p>

<code class="language-python"> cell = grid.get_cell(x, y) </code>

<br /> <br /> 
<h2> Advanced TextGrid functionality </h2>

<h3> Creating a blank grid with specified height and width </h3>

<p> This is useful for starting off with a “blank canvas” that you can populate in an algorithmically interesting way. Both of the lines of code below are valid ways of making a blank grid</p>

<pre class="language-python"><code>grid = TextGrid.blank(5, 3), grid = TextGrid.blank(width=5, height=3)
</code></pre>

<h3> Accessing a cell by its x, y coordinates </h3>

<p> The top left of the grid corresponds to x=0, y=0. x-coordinates get larger as you move to the right, and y-coordinates get larger as you move down. 
</p>

<pre class="language-python"><code> myCell = grid.get_cell(x,y)
</code></pre>

<h3> Setting the value of a certain cell in a grid by its x, y coordinates </h3>

<p> If you have a cell (such as one returned by get_cell) and you want to place it directly into a grid, you can do so with the following function: <code> grid.set_cell(x, y, myCell) </code></p>

<p> Once you create a cell, you can also change its value: </p>
<pre class="language-python"><code> 
  myCell.value = 'A'
</code></pre>

<p> Note: x and y should be integers and x must be in the range 0 to width-1 (inclusive) and y must be in the range 0 to height-1 (inclusive); value should be a string that is one character long </p>

<h3> Range loops with TextGrid </h3>

<p> The "for each" loop described above is the easiest way to loop over all of the cells in a grid. However, sometimes you want to write loops that access cells by their x, y coordinates. The code below demonstrates the standard nested for loop pattern to access all of the nucleotides in a genome. The outer for loop iterates over the rows (starting with the top row (y = 0) and moving on to the next row (y = 1)), and the inner for loop iterates over the columns. </p>

<pre class="language-python"><code> def example(filename): 
  grid = TextGrid(filename) 
  for y in range(grid.height): 
    # loop over all the rows 
      for x in range(grid.width): 
      # loop over all the columns 
      character = grid.get_cell(x, y) # do something with character 
      character.show()
      return grid
</code></pre>






















<!--<h2> Functions are like toasters </h2>

<img style="height:425px;max-width:500px;width: expression(this.width > 500 ? 500: true);"src={{pathToRoot}}img/pythonreader/functions/toasters.png alt="alt: An image of a toaster. A slice of bread goes inside the toaster as a parameter, and a piece of toast is returned ">

<p> Toasters take in an input (bread-like), does an operation to it (toast the bread), and returns output (toast). This makes toasters very similar to <b> functions</b>: functions also take an input, do an operation, and return an output.</p>

<p> A function is also able to be general enough to take in different parameters. For example, if you wanted to toast a bagel, you wouldn't get a new toaster. You can use the same toaster to toast bagels, too, in addition to bread. </p>-->

<!--<img style="height:380px;max-width:500px;width: expression(this.width > 500 ? 500: true);"src={{pathToRoot}}img/pythonreader/functions/bagel.png alt="alt: An image of a toaster. A bagel goes inside the toaster, and a toasted bagel is returned ">-->

<!-- <h2> Anatomy of a Function</h2>

<p>To understand how to defined functions which can take in data and can return data, let's disect a simple example of the definition of an average function. Average takes in two pieces of data and returns the mathematical average.</p>

<p><b>Definition</b>: The definition of average specifies that it needs to pieces of information by writing two variable names, separated by a comma <code>,</code> between the parenthesis in the definition line. In the body of the average function it can assume that the function call provided two pieces of information inside the function body average can refer to the first piece of information as variable <code>a</code> and the second as variable <code>b</code>. The definition of average specifies that it gives information back to ther caller via the line that starts with <code>return</code>.</p> -->

<!-- <p><b>Call</b>: Average is called in the main function. Information is provided for the function call to average between parantheses in the call: <code class="language-python">average(5.0, 12.0)</code>. The value that is returned from the function can be saved in a variable, as in this example: <code class="language-python">mid = average(5.0, 12.0)</code>.</p><p>You can step through these slides (click on the slides) to see some of the terminology:</p> -->
<!--<img src={{pathToRoot}}img/pythonreader/functions/call_def.png alt="alt: A function is named average is called in main. The function average is defined outside the main function ">-->
<!-- <p>
<iframe src="https://docs.google.com/presentation/d/e/2PACX-1vSYaBW4mDfSlOLuBGAFPF520wy83s8i79fZ8_jSe1jnHXN7RnYsu1w7-9Gg5Vd7ZKFX24SwRkfDv9y3/embed?start=false&loop=false&delayms=60000" frameborder="0" width="100%" height="500" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe>
</p> -->

<!-- <p>To better understand this, let's look at a few examples</p>


<h3>No Parameters, No Return Example </h3>
<pre class="language-python"><code>def print_intro():
  """
  Functions do not need to take in information and do not need
  to return information. Here is a simple example:
  """
  print("Welcome to class")
  print("It's the best part of my day") 

def main(): 
   print_intro()
</code></pre>

<h3> Parameter Example  </h3> -->
<!-- <pre class="language-python"><code>def print_opinion(num): 
  """
  This function requires a single piece of information!
  Inside the definition we will refer to the information provided
  as num.
  """
  if num == 5: 
     print("I love 5!") 
  else: 
     print("Whatever") 

def main(): 
  # when calling the function, we must provide the information
  print_opinion(5): 

  # which can be as a literal number or as a variable
  user_num = int(input("enter a num: "))
  print_opinion(user_num)
</code></pre> -->

<!-- <h3> Parameter and Return Example </h3>
<pre class="language-python"><code>def meters_to_cm(meters): 
   """
   This simple function expects information in: a number of meters
   and provides information back: the corresponding number of cm.
   It uses the return keyword followed by the information to be returned.
   """
   return 100 * meters

def main():
   # when you call this function, it gives you information back
   # a common practice is to save the result in a variable
   num_cm = meters_to_cm(5.1)
   print(num_cm)

   # you can use that information immediately
   print(meters_to_cm(9.5))
</code></pre> -->

<!-- <h3> Contrasting case: print vs. return: </h3>
<pre class="language-python"><code># how is this function 
def meters_to_cm_case1(meters): 
   return 100 * meters 

# Different than this function? 
def meters_to_cm_case2(meters) 
   print(100 * meters) 
</code></pre>

<p> Returning is not the same as printing. Return gives a number back to the part of the program that called your function. Print puts the value on the console. </p>

<h3> Multiple Return Statements </h3>
<p><pre class="language-python"><code>def max(num1, num2): 
   """
   this function has multiple return statements. When the function executes,
   if it hits a return statement it immediately halts and gives back the specified info
   """
   if num1 >= num2: 
      # this return statement only happens if the condition in the if-statement is true
      return num1    
   return num2

def main(): 
   larger = max(5,1)  
</code></pre></p> -->

<!-- <h3>Big Example</h3>

<p>Here is a big example of a medium sized program which was originally written in one large main file. By using functions, we can decompose the program into smaller, separate pieces. The code "using functions" is much better style. It is easier to read the main function. The flow of information is well controlled. It is longer, but mostly because of the extra comments, another important piece of writing programs with good style:</p> -->

<!-- <div class="row">



<div class="col-12 col-sm-6">
  <center><h3>Using Functions</h3></center>
  <pre class="language-python"><code>def main(): 
    print("Welcome to the CodeInPlace Game Show")
    print("Pick a door and win a prize")
    print("------------------------------------")

    door = get_door()
    prize = compute_prize(door)
    print('You win ' + str(prize) + ' treats')

def get_door():
    """
    Get door, asks the user to enter a door
    Reprompts the user until they enter 1, 2 or 3
    Returns the valid door choice as an int
    """
    door = int(input("Door: "))
    # while the input is invalid
    while door < 1 or door > 3 :
        # tell the user the input was invalid
        print("Invalid door!")
        # ask for a new input
        door = int(input("Door: "))
    return door

def compute_prize(door):
    """
    Compute prize, based off the door which is 
    given as a parameter. Returns the prize. 
    Uses many non-constant magic-numbers just to 
    make the game more fun to play in class!
    """
    prize = 4
    if door == 1:
        # what happens in door 1?
        prize = 2 + 9 // 10 * 100
    elif door == 2:
        # what happens in door 2?
        locked = prize % 2 != 0
        if not locked:
            prize += 6
    elif door == 3 :
        # what happens in door 3?
        for i in range(door):
            prize += i  
    return prize</code></pre>

</div>


<div class="col-12 col-sm-6">
  <center><h3>Without Functions</h3></center>
  <pre class="language-python"><code>def main(): 
    print("Welcome to the CodeInPlace Game Show")
    print("Pick a door and win a prize")
    print("------------------------------------")

    # Part 1: get the door number form the user
    door = int(input("Door: "))
    # while the input is invalid
    while door < 1 or door > 3 :
        # tell the user the input was invalid
        print("Invalid door!")
        # ask for a new input
        door = int(input("Door: "))

    # Part 2: compute the prize
    prize = 4
    if door == 1:
        prize = 2 + 9 // 10 * 100
    elif door == 2:
        locked = prize % 2 != 0
        if not locked:
            prize += 6
    elif door == 3 :
        for i in range(door):
            prize += i  

    # Part 3: report the prize
    print('You win ' + str(prize) + ' treats')</code></pre>

</div>
</div> -->

<hr/>


<!-- <p>A python program is made of many lines of code, stored in a file with a name like "example.py".
It's natural to have a way to divide the lines code up into sensible sub-parts, and these are called <b>functions</b>. Almost all the code you work with in Python is inside a function.

<h2>Python Function Syntax - "def"</h2>

<p>Suppose we have a Python program in the file example.py. The program text will be divided into many functions, each marked in the program text by the word <b>def</b>:

<p>
<img src={{pathToRoot}}img/pythonreader/functions/python-program-fns.png alt="alt: program is made of functions, each with def">


<p>Here is an example Python function named "foo". This function doesn't do anything sensible, just shows the syntax of a function.

<pre>
def foo():
    x = 1
    y = 2
    z = 3
    i = 0
</pre> -->

<!--

<pre>
def draw_colors():
    bit = Bit('5x5.world')
    bit.paint('blue')
    bit.move()
    bit.move()
    bit.paint('red')
</pre>
-->

<!-- <p>Parts of a function definition:

<ul>
 <li> <b>def</b> - A function begins with the word <code class=b>def</code>
 <li> <b>name</b> - def is followed by the function's name, here <code class=b>foo</code>
 <br>The name is chosen by the programer to reflect what the function does
 <br>Here "foo" is just a CS nonsense word
 <li> <b>parenthesis</b> - the name is followed by a pair of parenthesis and a colon <code class=b>():</code>
<br>Functions and parenthesis pairs <code class=b>()</code> frequently go together in Python syntax
 <li><b>body lines</b> - Indented within the def are the "body" lines of code which make up the function.
 <br>When a function runs, the computer runs its body lines from top to bottom.
</ul>


<p>Key points: A function starts with the word "def", has a name, and some lines of code

<h2>Function Call 1.0</h2>

<p>Say we have a function named "caller", and its body lines are run from top to bottom in the usual way:

<pre>
def caller():
    x = 6
    y = x + 1
    foo()   # call the "foo" function
    x = 7
...
</pre>

<p>To "call" a function is to invoke and run its lines of code.
The list below traces the sequence of the  caller() function running, calling the foo() function to run its lines, and then returning to finish the caller() lines.

<ol>
<li>Line 1: <code>x = 6</code> runs in the caller
<li>Line 2: <code>y = x + 1</code> runs in the caller
<li>Line 3: <code>foo()</code> runs, calling that function
 <br>-The run goes over to foo(), running the body lines there
 <br>-Note the required parenthesis <code>()</code> to call the function
 <br>-The run of foo() goes through its lines
 <br>-When foo() is done, the run resumes in the caller code...
<li>Line 4 <code>x = 7</code> runs in the caller
</ol>

<p>The run of lines in the caller code is suspended while called function runs.
Or equivalently, we could say that the computer runs one function at a time, so when it's running foo(), it's not running caller() lines and vice-versa.

<p>Here's a diagram showing the function-call sequence.
The run starts with the lines in the caller function and goes over to run the lines in the called function. When the called function is finished, the run resumes where it left off in the caller.

<p>
<img src={{pathToRoot}}img/pythonreader/functions/python-fncall0.png alt="alt: function call run goes from caller, to called, back to caller">

<p>Bonus fact: the variables, such a "x" above, are separate and independent for each function, so x in caller is a completely separate variable from x in foo.

<p>Key point Call a function by its name with parenthesis added, like <code>foo()</code>

<h2>Variant: Obect-Oriented Noun.Verb Function Call</h2>

<p>Another way to call a function is the object-oriented aka noun.verb style, like this:

<pre>
    bit.move()
</pre>

<p>Here <code>bit</code> is Python data of some sort, and <code>.move()</code> is a function to run on that data. At its heart, this is still just a function call, but the data to work on is listed first, then a dot, then then the function name. Python mixes regular function calls and OOP function calls. Many languages use this "OOP" style, as it has a nice quality of thinking about what data you want to work on first, and then what operation to perform on that data.


<h1>Parameter Passing</h1>

<p>Suppose we have a paint_window() function that fills a computer window with a color. We want a way to tell the function <b>what</b> color to use when calling it &mdash; blue or red or whatever. 

<p>A parameter is extra information supplied by the caller that customizes the run of the called function. We will learn all the details of parameters in time. For today, it's sufficient that a function can take a parameter, and the parameter value is "passed in" as part of the call simply by including the desired value within the parenthesis.

<p>So for example to call the paint_window() function to paint the window blue might look like the following.

<pre>
paint_window('blue')
</pre>

<p>The syntax <code>'blue'</code> is a Python string, which is the way to express a bit of text like this.

<p>Calling the function to paint the window yellow would look like:

<pre>
paint_window('yellow')

</pre>

<p>A programmer would say the code "calls the paint_window function" and "passes in 'yellow' as the parameter".

<p>You could say that <code>paint_window</code> is the verb we want the computer to do, and 'blue' or 'yellow' are difference noun modifiers we provide to the action.

<h3>Rule 3: Pass a parameter value within the parenthesis of a function call</h3>

<p>The existence of parameters perhaps explains why the parenthesis are part of the function-call syntax &mdash; the parens are the place for the parameter values.

<p>We will see more details of how parameters work, but the case above is pretty simple. Call the function by name, and between the parenthesis there is a possibility of passing in extra information the function uses.

<h2>print() Parameter Example</h2>

<p>This is a "in the interpreter" demo/example you can try. There is a function in Python called <code>print()</code>. It does many things, but one simple thing it does is take in a parameter value and print it out to the screen. Though unglamorous, this is a way to see function call and parameters in action.

<pre>
>>> print('hi')     # Call print() passing in param 'hi'
hi                  # Output produced by print()
>>> print(23)
23
>>> print(4 + 5)
9
</pre>

<p>What you see here is calling the <code>print()</code> by its name as usual, and in between the parenthesis passing in parameter value like <code>'hi'</code> or <code>23</code>. The print() lines take in that parameter value and print it to the screen.


<p>A function can accept multiple more parameter values, and in fact print() accepts any number of parameters. The multiple parameter values are listed within the parenthesis, separated by commas, like this:

<pre>
>>> print('hi', 22)
hi 22
>>> print('behold', 123, 'donuts')
behold 123 donuts
>>> print(4, 8, 15, 16, 'woot')
4 8 15 16 woot
</pre> -->



<!--

<p>Crazy leftovers

<h2>Bit Functions First Day</h2>
<ul class="slide">
<li>
<pre>
bit = Bit(filename)  # Create bit in named world
                     # filename is a value like '3x3.world'
bit.move()   # move forward 1 square (err if way is blocked)
bit.left()   # turn left
bit.paint('blue')  # paint current square blue
                   # 'red' and 'green' work too
</pre>
<li><code>bit.move()</code> - calling a function named "move()"
<br>- "calling" a function, another word for running it
<li>Required syntax - () at the end of the function name
</ul>


<ul class="slide">
<li>In Python, "def" introduces a function
<li>We'll do that a lot in CS106AP
<li>But today is the first
</ul>


<h2>4 Things About def Functions</h2>

<ul class="slide">
<li>1. A function has a name, e.g. "blue_green"
<li>2. A function contains lines of code
<li>3. A function can be "run", aka "called"
<br> - the Run button does this
<br>-This runs the lines in the function
<li>4. A function has parameter data passed in
<br> - e.g. "filename" within the parenthesis
<br> - more advanced topic for later
</ul>


<h2>Def Talk</h2>

<ul class="slide">
<li>We've defined functions .. looks like
<pre>
def blue_row(bit):
    bit.paint('blue')
    ...
</pre>
<li>There 2 ways to call a function in Python
<li>Form 1 - noun.verb or "object oriented"
<pre>
   bit.move()
   bit.paint('blue')
   bit.move()
</pre>
<li>Function call: go do that, come back when done
<li>"invoke"
<li>Form 2 - plain function call
<pre>
   blue_row(bit)
</pre>
</ul>


<h2>Foreshadow: Big Picture</h2>
<ul class="slide">
<li>Program  made of functions
<li>How do functions exchange data?
<li>Function: black box model
<br>-data in: parameters
<br>-data out: return
<li>Today 1 function, later build whole picture
</ul>


<h2>"score" Function Example</h2>

<ul class="slide">
<li>This simple "score" function - maybe it's inside a computer game
<li>Takes in "n" and "limit" parameters, and returns a score value
<li>If n is greater than the limit, returns 2*n + 10 (i.e. a bonus of 10)
<li>Otherwise returns 2*n
<li>Here's a def, this code works, followed by caller code
<pre>

<p>def score(n, limit):
    if n > limit:
        return 2 * n + 10
    return 2 * n

</pre>
<li>"Caller" code:
<pre>
x = score(6, 10)
<h1>now x is 12</h1>
y = score(7, 10)
z = score(11, 10)
<h1>now z is 32</h1>
</pre>
</ul>

<h2>Function Call Rules</h2>

<ul class="slide">
<li>We have "caller" code, and "called" function
<li>Call a function by its name
<pre>
<h1>e.g. caller code</h1>
x = score(6, 10)
<h1>now x is 12</h1>
y = score(7, 10)
z = score(11, 10)
</pre>
<li>Caller must provide a value for each parameter, inside the parenthesis
<li>Parameters match up by position - 1st to 1st, 2nd to 2nd
<br>Parameter values can be expressions, like 2 + 6
<li>Called code runs .. using caller-provided parameter values
<br>Caller code suspends while called runs
<br>-Each parameter is like a variable, = assigned with value from caller
<li><b>return <i>value</i></b> in called function
<br>-exit called function immediately
<br>-return the <i>value</i> to the caller code
<br>-caller can use = or whatever to store returned value
<br>-caller code resumes running
<li>Python edge case: if return value is not provided, Python uses <code>None</code> as the default return value for any function call
</ul>

<br>
<img src='lecture-functioncall.png' alt='score function called by score(6, 10)'>

<p>Hack mode demo, score, calls with various parameter values/expressions

<h2>We Need To Talk About Parameter Names</h2>

<ul class="slide">
<li>People are used to words having meaning
<li>With parameters this is only half true!
<li>Consider these three functions
<pre>
def score(n, limit):
    if n > limit:
        return 2 * n + 10
    return 2 * n

<p>def score2(x, y):
    if x > y:
        return 2 * x + 10
    return 2 * x

<p>def score3(zip, zap):
    if zip > zap:
        return 2 * zip + 10
    return 2 * zip
</pre>
<li>These 3 functions are effectively identical
<li>The "n" is just a placeholder meaning "the first parameter"
<li>Using the word "x' works just as well to mean "the first parameter"
<li>Caller does not need to use "n" as the first parameter
</ul>


<h2>Each Function Has Its Own Variable Names ("scope"</h2>

<ul class="slide">
<li>Each function gets its own variables, independent
<li>Inside a function = its indented lines
<li>If one function has an "n"
<li>That's totally separate from an "n" in another function or somewhere else
<li>Parameters do not match up by <b>name</b> like "n" to "n"
<li>Parameters for function call match up by <b>position</b>
</ul>

<p>Demo of this ("n" inside the function vs "n" outside)

<pre>
>>> def score(n, limit):
        if n > limit:
            return 2 * n + 10
        return 2 * n
>>> score(6, 10)
12
>>> n = 13
>>> n = 13
>>> n
13
>>> score(6, 10)
12
>>> score(13, 10)
36
</pre>


<h2>Parameters - What To Remember</h2>

<ul class="slide">
<li>Variable and parameter names in each function are independent / separate
<li>Calling a function, match up parameter values by position
<li>e.g. Calling a foo() function - say it takes 3 parameters
<li>Pass 3 values within the parenthesis
<pre>
foo(17, 13, 'red')
</pre>
</ul>

<hr>

<h2>Optional: Lucky Return Example</h2>

<p>lucky(n) example - given an int n, the function lucky(n) returns
the lucky version of that number. We'll say that for "teen" ints in the range 13..19,
the lucky value is 20. For all other ints, the lucky value is just n unchanged.

<p>Here is code that implements lucky(n):
<pre>
def lucky(n):
    """Given int n, returns its 'lucky' value."""
    if n >= 13 and n <= 19:
        return 20
    # Get to this line only if above test is false
    return n
</pre>


<p>Calling lucky() looks like:

<pre>
...
x = lucky(10)
y = lucky(15)
...
</pre>



<h2>lucky_sum Example</h2>

<p>lucky_sum(a, b, c) - computes the sum of the lucky versions
of a,b,c. Calls lucky(n) 3 times to get the lucky values.

<pre>
def lucky_sum(a, b, c):
    # Here we call lucky() a few times
    # to build up our sum.
    sum = lucky(a)
    sum += lucky(b)
    sum += lucky(c)
    return sum
    # Alternately could write it as a big expression
    # without using a sum variable:
    # return lucky(a) + lucky(b) + lucky(c)
</pre>


<h2>Runnable lucky_sum - Autograde Table</h2>

<p>The example below calls the lucky_sum() function with various parameter values. Prints out and checks the return value - one per row. This little table is a good way to think about a function - various input cases and what value the function returns.

<p>What happens if there is no return, function "falls off the end" - easy to write the code and forget to put the return

<p> &gt;

<a href='https://parlante.org/make/fn/lucky_sum'>lucky_sum</a>

-->


    </div>
</body>



